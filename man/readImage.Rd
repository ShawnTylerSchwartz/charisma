% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/readImage.R
\name{readImage}
\alias{readImage}
\title{Import image and generate discrete color classification(s)}
\source{
Many of the pixel filtering functions, documentation, and descriptions here
were either copied directly or modified/adapted from \link[colordistance]{loadImage}.
\link{https://cran.r-project.org/web/packages/colordistance/index.html}
}
\usage{
readImage(
  path,
  lower = NULL,
  upper = NULL,
  alpha.channel = TRUE,
  mapping = charisma::color.map
)
}
\arguments{
\item{path}{Path to image (a string).}

\item{lower}{RGB or HSV triplet specifying the lower bounds for background pixels.
Default upper and lower bounds are set to \code{NULL} given that no background
filtering is needed for images with transparent backgrounds
(the default assumed image type with file extension ".png").}

\item{upper}{RGB or HSV triplet specifying the upper bounds for background pixels.
Default upper and lower bounds are set to \code{NULL} given that no background
filtering is needed for images with transparent backgrounds
(the default assumed image type with file extension ".png"). Determining these
bounds may take some trial and error, but the following bounds may work for certain
common background colors: \itemize{ \item Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) \item White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1, 1)
\item Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) \item Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) } If no background filtering is
needed, set bounds to some non-numeric value (\code{NULL}, \code{FALSE},
\code{"off"}, etc); any non-numeric value is interpreted as \code{NULL}.}

\item{alpha.channel}{Logical. If available, should alpha channel transparency be
used to mask background?}

\item{mapping}{Data Frame. Color mapping definitions with min and max ranges for
H, S, and V. Provided by default. See \code{\link{loadCustomColorMapping}} for more details
regarding loading in a CSV file with custom color definitions.}
}
\value{
A list with original image ($original.rgb, 3D array), 2D matrix with background pixels identified
($filtered.2d), the path to the original source image ($path), matrix of hex values for raster plotting
of classified image ($hex.matrix), a matrix of corresponding discrete color names for
spatial color pattern analyses ($cname.matrix), the relative proportions of each color in the image
(not including background pixels) ($color.frequencies), and the spatial density scores for each color
classified in the image ($spatial.density).
}
\description{
Imports a single image and returns a list with the absolute path to the original image,
original image as a 3D array, a 2D matrix with background pixels identified,
HSV and RGB coordinates, the original dimensions of the 3D image, binary color classifications,
total number of discrete colors (k), a matrix of hex values for raster plotting of classified image,
a matrix of corresponding discrete color names for spatial color pattern analyses,
the relative proportions of each color in the image (not including background pixels),
and the spatial density scores for each color classified in the image.
}
\details{
The upper and lower limits for background pixel elimination set the
inclusive bounds for which pixels should be ignored for the 2D arrays; while
all background pixels are ideally a single color, images photographed against
"uniform" backgrounds often contain some variation, and even segmentation
done with photo editing software will produce some variance as a result of
image compression.

The upper and lower bounds represent cutoffs: any pixel for which the first
channel falls between the first upper and lower bounds, the second channel
falls between the second upper and lower bounds, and the third channel falls
between the third upper and lower bounds, will be ignored. For example, if
you have a green pixel with RGB channel values \link{0.1, 0.9, 0.2}, and your
upper and lower bounds were (0.2, 1, 0.2) and (0, 0.6, 0) respectively, the
pixel would be ignored because 0 <= 0.1 <= 0.2, 0.6 <= 0.9 <= 1, and 0 <= 0.2
<= 0.2. But a pixel with the RGB channel values \link{0.3, 0.9, 0.2} would not be
considered background because 0.3 >= 0.2.
}
\note{
The 3D array is useful for displaying the original image, the 2D arrays (HSV and RGB) are treated as
rows of data for discrete color classification in the rest of the package, and the matrix of hex values
is used for creating a rasterized graphic (sprite plot) to see a regenerated image displaying which colors
were identified via discrete color classification (these colors are defined in the \code{default.hex} column
of \code{charisma::color.map} and/or a custom defined color mapping built with \code{\link{loadCustomColorMapping}}).
}
\examples{
demoImg <- charisma::readImage(system.file("extdata",
"Tangara/Tangara_transparent/Tangara_01.png", package = "charisma"))

demoImgWhiteBG <- charisma::readImage(system.file("extdata",
"Tangara/Tangara_whitebg/Tangara_01.jpeg", package = "charisma"),
lower = c(0.8, 0.8, 0.8); upper = c(1, 1, 1), alpha.channel = FALSE)

}
